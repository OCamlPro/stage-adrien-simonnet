\documentclass{beamer}

\usepackage{mathtools}
\usepackage[ruled,vlined,linesnumbered]{algorithm2e}
\usepackage{listings}

\usetheme{Madrid}

\title[Soutenance de stage STL]{Heuristique d'inlining complexe}
\subtitle{Heuristique d'inlining complexe}
\author{Adrien Simonnet}
\institute{Sorbonne Université}
\date{Avril - Septembre 2023}
\titlegraphic{\includegraphics[height=1cm]{logo.png}}
%\logo{\includegraphics[height=1cm]{logo.png}}

\begin{document}

\frame{\titlepage}

\begin{frame}{Plan}
    \tableofcontents
\end{frame}

\begin{frame}{Introduction}
    OCamlPro

    \begin{itemize}
        \item Fondée en 2011
        \item Issue de l'INRIA
        \item Spécialisée dans les langages de programmation
    \end{itemize}

    Équipe flambda

    \begin{itemize}
        \item Vincent Laviron et Pierre Chambart
        \item Optimisations dans le compilateur OCaml
    \end{itemize}

\end{frame}

\begin{frame}{Introduction}{Inlining}
    Optimisation centrale d'un compilateur

    \begin{block}{Avantages}
        \begin{itemize}
            \item Améliore significativement les performance 
            \item Permet aux autres optimisations de s'activer
        \end{itemize}
    \end{block}

    \begin{block}{Coûts}
        \begin{itemize}
            \item Temps de compilation
            \item Taille des exécutables
        \end{itemize}
    \end{block}

    Nécessité de trouver des heuristiques
\end{frame}

\begin{frame}[fragile]{Introduction}{Langage jouet}
    Sous-ensemble du noyau fonctionnel d'OCaml

    \begin{itemize}
        \item Lambda-calcul
        \item Opérations élémentaires
        \item Fermetures (mutuellement) récursives
        \item Types Somme et filtrage par motifs
    \end{itemize}

    \begin{exampleblock}{Exemple}
        \begin{lstlisting}[language=caml]
type int_list = Nil | Cons of int * int_list
let rec map = fun f -> fun l -> match l with
| Nil -> Nil
| Cons (x, ls) -> Cons (f x, map f ls)
in map (fun x -> x + 10) (Cons (1, Cons (2, Nil)))
        \end{lstlisting}
    \end{exampleblock}
\end{frame}

\section{Analyse lexicale}

\begin{frame}{Analyse lexicale}
    Lexique identique à celui d'OCaml

    \begin{itemize}
        \item Uniquement les fonctionnalités intéressantes
    \end{itemize}

    Jetons générés par OCamllex
\end{frame}

\section{Analyse syntaxique}

\begin{frame}{Analyse syntaxique}
    Grammaire (presque) identique à celle d'OCaml

    \begin{itemize}
        \item Pas de filtrage par motif ``profond"
        \item Pas de valeurs récursives
        \item Pas de types
    \end{itemize}

    AST généré par Menhir
\end{frame}

\section{Résolution des noms}

\begin{frame}{Résolution des noms}
    Rafraîchissement de l'AST

    \begin{itemize}
        \item Les variables deviennent des identifiants uniques
        \item Index pour le nom des constructeurs
        \item Autorise les variables libres
    \end{itemize}

    \begin{block}{Conversion}
        $\mathbb{E}_{ast} \times \left( \mathbb{V}_{ast} \mapsto \mathbb{V} \right) \times \left( \mathbb{T}_{ast} \mapsto \mathbb{T} \right) \vdash_{\text{ast'}} \mathbb{E} \times \left( \mathbb{V} \mapsto \mathbb{V}_{ast} \right) \times \left( \mathbb{V}_{ast} \mapsto \mathbb{V} \right)$
    \end{block}

    \begin{exampleblock}{Exemple}
        $\text{Fun}(\text{``x"}, \text{Var} ~ ``y") ~ \emptyset ~ \emptyset \vdash \text{Fun}(0, \text{Var} ~ 1) ~ \lbrace 0 \rightarrow \text{``x"} \rbrace ~ \lbrace \text{``y"} \rightarrow 1 \rbrace$
    \end{exampleblock}

    \begin{exampleblock}{Exemple}
        $\text{Cons}(\text{``Some"}, [\text{``x"}]) ~ \lbrace \text{``x"} \rightarrow 0 \rbrace ~ \lbrace \text{``Some"} \rightarrow 0 \rbrace \vdash \text{Cons}(0, [0]) ~ \emptyset ~ \emptyset$
    \end{exampleblock}
\end{frame}

\section{Analyse du flot de contrôle}

\begin{frame}{Graphe de flot de contrôle}
    \begin{itemize}
        \item Ensemble de basic blocks \alert{clos}
        \item Chaque type de bloc a sa sémantique
        \item Expressions construisent des valeurs
        \item Valeurs déclarées par un identifiant unique
        \item Instruction = déclaration ou branchement
        \item Basic block = suite de déclarations puis branchement
    \end{itemize}

    \begin{block}{Conversion}
        $\mathbb{E}_{ast'} \times \mathbb{V} \times \mathcal{P}(\mathbb{V}) \times \mathbb{I} \vdash_{\text{cfg}} \mathbb{I} \times \mathcal{P}(\mathbb{V}) \times (\mathbb{P} \mapsto (\mathbb{B} \times \mathbb{I}))$
    \end{block}

    \begin{exampleblock}{Exemple}
        $\text{Fun}(1, \text{Var} ~ 1) ~ 0 ~ \emptyset ~ e \vdash \text{Let}(0, \text{Clos}(0, \emptyset), e) ~ \emptyset ~ \lbrace 0 \rightarrow \text{Clos}([1], \emptyset, \text{Return} ~ 1) \rbrace$
    \end{exampleblock}


    \begin{exampleblock}{Exemple}
        $e ~ v ~ V ~ i \vdash_{\text{cfg}} e' ~ V_e ~ B_e$
    \end{exampleblock}
\end{frame}

\subsection{Nettoyage des alias}

\begin{frame}{Graphe de flot de contrôle}{Nettoyage des alias}
    Le CFG peut contenir des alias.

    \begin{exampleblock}{Exemple}
        $(\text{Var} ~ x_1) ~ \overline{0} ~ \emptyset ~ (\text{Return} ~ \overline{0}) \vdash_{\text{cfg}} (\text{let} ~ \overline{0} = x_1 ~ \text{in} ~ \text{Return} ~ \overline{0}) ~ \lbrace x_1 \rbrace ~ \emptyset$
    \end{exampleblock}

    La passe de nettoyage supprime tous les alias.

    \begin{exampleblock}{Exemple}
        $\text{let} ~ \overline{0} = x_1 ~ \text{in} ~ \text{Return} ~ \overline{0} \rightarrow \text{Return} ~ x_1$
    \end{exampleblock}
\end{frame}

\subsection{Spécialisation}

\begin{frame}{Graphe de flot de contrôle}{Spécialisation}
    La spécialisation consiste à dupliquer des blocs.

    \begin{itemize}
        \item Améliore la précision de l'analyse
        \item Première étape de l'inlining
    \end{itemize}

    La copie doit :

    \begin{itemize}
        \item Conserver les invariants du CFG
        \item Modifier les appels directs
    \end{itemize}

    Les blocs sont choisis selon leur taille.
\end{frame}

\section{Analyse de valeurs par interprétation abstraite}

\begin{frame}{Analyse de valeurs par interprétation abstraite}
    Etape la plus compliquée et probablement la plus importante.
    \begin{itemize}
        \item Rendre les appels directs pour inliner
        \item Informations cruciales pour les heuristiques
    \end{itemize}

    L'analyse se fait par point d'allocation.
    \begin{itemize}
        \item Garanties de terminaison
        \item Autorise la récursivité
    \end{itemize}

    L'analyse a lieu sur le CFG.
    \begin{itemize}
        \item Importance des invariants
        \item Disposer des blocs
    \end{itemize}
\end{frame}

\subsection{Domaines}

\begin{frame}{Analyse de valeurs par interprétation abstraite}{Domaines}
    Les entiers sont représentés de la manière la plus simple qui soit, c'est à dire des singletons munis de Top.
    
    \begin{block}{Abstraction}
        $\text{Top} : \mathbb{I}$

        $\text{Singleton} : \mathbb{Z} \mapsto \mathbb{I}$
    \end{block}

    L'union de deux entiers donne toujours Top sauf lorsqu'il s'agit de deux singletons de même valeur.

    \begin{block}{Union}
        $$
        x \sqcup y =
        \begin{cases}
            \text{Singleton} ~ i \text{ si } x = y = \text{Singleton} ~ i  \\
            \text{Top} \text{ sinon}
        \end{cases}
        $$
    \end{block}
\end{frame}

\begin{frame}{Analyse de valeurs par interprétation abstraite}{Domaines}
    Le domaine pour les fermetures est un environnement d'identifiant vers contexte, où l'identifiant correspond au pointeur de fonction, et le contexte correspond aux variables libres.
    \begin{block}{Abstraction}
        $\mathbb{F} \coloneqq \mathbb{P} \mapsto \mathcal{P}(\mathcal{P}(\mathbb{V}))$ (fermeture)
    \end{block}

    L'union de deux fermetures consiste à conserver les entrées distinctes et d'unir les points d'allocations des entrées communes.% Deux entrées communes, c'est à dire ayant comme clé le même pointeur, sont censées avoir le même environnement, dans le cas contraire il s'agit d'une erreur d'implémentation.
    
    \begin{block}{Union}
        $$
        x \sqcup y = z \rightarrow
        \begin{cases}
            x(z) \cup y(z) \text{ si } z \in \mathcal{D}(x) \text{ et } z \in \mathcal{D}(y) \\
            x(z) \text{ si } z \in \mathcal{D}(x) \\
            y(z) \text{ si } z \in \mathcal{D}(y)
        \end{cases}
        $$
    \end{block}
\end{frame}

\begin{frame}{Analyse de valeurs par interprétation abstraite}{Domaines}
    Le domaine pour les unions taggées est un environnement d'identifiant vers contexte, où l'identifiant correspond au tag, et le contexte correspond au contenu de l'union.

    \begin{block}{Abstraction}
        $\mathbb{C} \coloneqq \mathbb{T} \mapsto \mathcal{P}(\mathbb{V})^{*}$ (union taggée)
    \end{block}

    L'union de deux valeurs taggées consiste à conserver les entrées distinctes et d'unir les points d'allocations des entrées communes.% Deux entrées communes, c'est à dire ayant comme clé le même tag, sont censées avoir le même contenu, dans le cas contraire il s'agit d'une erreur d'implémentation.
    
    \begin{block}{Union}
        $$
        x \sqcup y = z \rightarrow
        \begin{cases}
            \left( x(z)_i \cup y(z)_i \right)_{i=1}^{i=n} \text{ si } z \in \mathcal{D}(x) \text{ et } z \in \mathcal{D}(y) \\
            x(z) \text{ si } z \in \mathcal{D}(x) \\
            y(z) \text{ si } z \in \mathcal{D}(y)
        \end{cases}
        $$
    \end{block}
\end{frame}

\subsection{Valeur abstraite}

\begin{frame}{Analyse de valeurs par interprétation abstraite}{Valeur abstraite}
    Une valeur abstraite est un entier, une fermeture ou une valeur taggée

    \begin{block}{Abstraction}
        $\text{IntDomain} : \mathbb{I} \mapsto \mathbb{A}$

        $\text{ClosureDomain} : \mathbb{F} \mapsto \mathbb{A}$

        $\text{ConstructorDomain} : \mathbb{C} \mapsto \mathbb{A}$
    \end{block}
\end{frame}

\subsection{Abstraction de la pile}

\begin{frame}{Analyse de valeurs par interprétation abstraite}{Abstraction de la pile}
    Détection de motifs

    \begin{exampleblock}{Exemple}
        ABCBC a un motif BC de taille 2 et sera remplacée par ABC
    \end{exampleblock}

    Conserver uniquement les n derniers appels (n-CFA)

    \begin{exampleblock}{Exemple}
        En 1-CFA, la pile d'appels ABCBC sera remplacée par C
    \end{exampleblock}
\end{frame}

\iffalse
\begin{frame}{Définitions}
    L'algorithme d'analyse prend une liste des blocs à analyser (pointeur, en-tête, pile et usine), une fonction d'abstraction de la pile, l'ensemble des blocs du programme, l'ensemble des usines pour chaque contexte de chaque bloc déjà analysé et renvoie en-tête et usine pour chaque bloc.

    $\text{analyse} : (\mathbb{P} \times \overline{\mathbb{B}} \times \mathbb{S} \times \mathbb{U})^{*} \times (\mathbb{S} \mapsto \mathbb{S}) \times (\mathbb{P} \mapsto \mathbb{B}) \times (\mathbb{P} \mapsto ((\mathbb{S} \times \overline{\mathbb{B}}) \mapsto \mathbb{U})) \mapsto (\mathbb{P} \mapsto (\overline{\mathbb{B}} \times \mathbb{U}))$

    L'analyse d'un bloc se fait par la fonction $`analyse_de_bloc`$ qui à partir d'un bloc, d'une pile, d'un environnement et d'une usine renvoie une liste de blocs à analyser.

    $`env_de_bloc`$ est une fonction qui génère l'environnement à partir de l'en-tête d'un bloc et les valeurs abstraites qui lui sont passées.
\end{frame}

\begin{frame}{Algorithme}
    \begin{algorithm}[H]
        \DontPrintSemicolon
        \SetAlgoLined
        \SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
        \Input{l pile\_abs B U}
        \BlankLine
        \tcp{Il ne reste plus aucun bloc à analyser.}
        \eIf{l est vide}{
           \Return $U$ telle que pour chaque bloc sa valeur soit l'union des usines et paramètres de chaque contexte de pile de ce bloc. \tcp{Tous les contextes de pile sont fusionnés.}
        }{
           $p, b, s, u \gets \text{hd}(l)$ \tcp{Le premier bloc à analyser.}
           $l' \gets \text{tl}(l)$ \tcp{Les autres blocs à analyser.}
           $\overline{s} \gets \text{pile\_abs}(s)$ \tcp{Abstraction de la pile.}
           $c \gets (\overline{s}, b)$ \tcp{Le contexte (pile et en-tête).}
        
           \BlankLine
           \tcp{Ce bloc a déjà été analysé.}
           \eIf{$p \in \mathcal{D}(U)$}{
              $U_p \gets U[p]$ \tcp{Les usines associées à ce bloc.}
              
              \BlankLine
              \tcp{Ce contexte a déjà été analysé pour ce bloc.}
              \eIf{$c \in \mathcal{D}(U_p)$}{
                 $u_c \gets U_p$[c] \tcp{L'usine associée à ce contexte.}
                 $u_2 \gets u_c \cup u$ \tcp{Union de l'ancienne et la nouvelle usine.}
        
                 \BlankLine
                 \tcp{L'ancienne usine et la nouvelle ont convergé.}
                 \eIf{$u_2 = u_c$}{
                    \BlankLine
                    \tcp{La pile d'appels est vide.}
                    \eIf{s est vide}{
                       \Return{analyse(l', pile\_abs, B, U)} \tcp{On continue avec les prochains blocs.}
                    }{
                       $p_2, args \gets hd(s)$ \tcp{Le contexte vers lequel renvoyer.}
                       $s_3 \gets tl(s)$ \tcp{Les autres blocs à analyser.}
                       $b_2 \gets \text{Return}(\emptyset, args)$ \tcp{Le bloc de retour recevra Bottom.}
        
                       \BlankLine
                       \Return{$\text{analyse}((p_2, b_2, s_3, u_2) :: l', \text{pile\_abs}, B, U)$} \tcp{On analysera le bloc appelant avec Bottom comme résultat.}
                    }
                 }{
                    $b_2, i \gets B(p)$ \tcp{L'en-tête et le corps de ce bloc.}
                    $l_2 \gets \text{analyse\_de\_bloc}(i, s, \text{env\_de\_bloc}(b_2, b), u_2)$ \tcp{On analyse ce bloc et on récupère les prochains à analyser.}
        
                    $U_p[c] \gets u_2$ \tcp{On met à jour l'usine pour ce contexte.}
                    $U[$p$] \gets U_p$ \tcp{On met à jour les usines pour ce bloc.}
        
                    \BlankLine
                    \Return {$\text{analyse}(l' @ l_2, \text{pile\_abs}, B, U)$} \tcp{Récursion sur les nouveaux blocs à analyser.}
                 }
              }{
                 \tcc{Page suivante}
              }
           }{
              \tcc{Page suivante}
           }
        }
        \caption{Analyse du programme}
    \end{algorithm}
\end{frame}
\fi

\subsection{Terminaison}

\begin{frame}{Analyse de valeurs par interprétation abstraite}{Terminaison}
    Idées justifiant la terminaison de l'analyse

    \begin{itemize}
        \item Identifiants jamais générés
        \item Un point d'allocation est un identifiant
        \item Nombre fini de valeurs
        \item L'union de deux usines converge
        \item Abstraction de la pile d'appels
    \end{itemize}
\end{frame}





\section{CFG exécutable}

\begin{frame}{CFG exécutable}
    Représentation plus bas-niveau que le CFG

    \begin{itemize}
        \item Concrétise les traits de langage (n-uplets)
        \item Unifie les blocs et branchements
        \item Fixe la sémantique des sauts
        \item Explicite les opérations sur la pile
    \end{itemize}

    \begin{block}{Conversion}
        $\mathbb{B}_{cfg} \times \mathbb{I} \vdash_{\text{cfg'}} \mathbb{B} \times (\mathbb{P} \mapsto \mathbb{B})$
    \end{block}

    \begin{exampleblock}{Exemple}
        $a ~ i \vdash_{\text{cfg'}} a' ~ i' ~ B$
    \end{exampleblock}
\end{frame}

\subsection{Propagation}

\begin{frame}{CFG exécutable}{Propagation}
    Faire apparaître les résultats de l'analyse

    \begin{itemize}
        \item Expressions transformées en constantes
        \item Éliminations de branches
        \item Appels indirects transformés en appels directs
    \end{itemize}
\end{frame}

\subsection{Inlining}

\begin{frame}{CFG exécutable}{Inlining}
    Intégrer le contenu d'un bloc à la place d'un appel direct

    \begin{itemize}
        \item Renomme les arguments
        \item Modifie les piles
        \item Autorise les sauts vers l'intérieur d'une fonction
    \end{itemize}

    Sont inlinés tous les blocs appelés exactement 1 fois

    \begin{block}{Conversion}
        $\mathbb{B}_{cfg} \times \mathbb{I} \vdash_{\text{cfg'}} \mathbb{B} \times (\mathbb{P} \mapsto \mathbb{B})$
    \end{block}

    \begin{exampleblock}{Exemple}
        $a ~ i \vdash_{\text{cfg'}} a' ~ i' ~ B$
    \end{exampleblock}
\end{frame}

\subsection{Interprétation}

\begin{frame}{CFG exécutable}{Interprétation}
    Interpréter le CFG

    \begin{itemize}
        \item Tester la validité des transformations
        \item Réaliser des benchmarks
    \end{itemize}
\end{frame}

\section{Conclusion}

\begin{frame}{Conclusion}
    Importance des représentations intermédiaires

    \begin{itemize}
        \item Transformations simples
        \item Sémantique riche d'informations
    \end{itemize}

    L'interprétation abstraite c'est compliqué

    \begin{itemize}
        \item Difficultés pour traiter les piles
        \item Complexité (certainement) exponentielle
    \end{itemize}

    Résultats sur l'inlining

    \begin{itemize}
        \item Toujours inliner les petits blocs
        \item D'autres heuristiques nécessaires pour les plus gros blocs
    \end{itemize}

    Expérimentations à mener

    \begin{itemize}
        \item Tester sur de vrais programmes
        \item Exploiter les résultats
    \end{itemize}
\end{frame}



\iffalse
\subsection{Langage source}

\subsubsection{Lambda-calcul}

\begin{frame}[fragile]{Langage source}{Lambda-calcul}
    Les trois constructions du lambda-calcul que sont les variables, l'application et l'abstraction sont évidemment des fonctionnalités indispensables.
    \begin{lstlisting}[language=caml]
        let id = fun x -> x in
        let x = id y in x
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Langage source}{Opérations élémentaires}
    La manipulation des entiers et le branchement conditionnel sont incontournables pour réaliser des programmes dignes de ce nom.
    \begin{lstlisting}[language=caml]
        if c then x + 1 else x - 1
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Langage source}{Fermetures (mutuellement) récursives}
    La prise en compte de la récursivité est fondamentale, premièrement en terme d'expressivité du langage (pour réaliser des tests poussés), deuxièmement il est intéressant de prendre en compte la complexité liée à l'impossibilité d'inliner tous les appels récursifs potentiels. La récursivité mutuelle permet d'ajouter une couche de complexité notamment lors de l'analyse.
    \begin{lstlisting}[language=caml]
        let rec f = fun x -> g x
        and g = fun y -> f y in f 0
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Langage source}{Types Somme et filtrage par motifs}
    La possibilité de construire des types Somme est une des fonctionnalités essentielles d'OCaml, permet de représenter quasiment n'importe quelle structure de données et d'augmenter la complexité de l'analyse de valeurs. De plus, de la même manière que le branchement conditionnel, le filtrage par motifs se prête particulièrement bien à l'inlining puisque connaître le motif peut permettre de filtrer de nombreuses branches et donc d'alléger un potentiel inlining.
    \begin{lstlisting}[language=caml]
        type int_list =
        | Nil
        | Cons of int * int_list

        let rec map = fun f -> fun l ->
        match l with
        | Nil -> Nil
        | Cons (x, ls) -> Cons (f x, map f ls)
        in map (fun x -> x + 10) (Cons (1, Cons (2, Nil)))
    \end{lstlisting}
\end{frame}


\begin{frame}{Langage utilisé}
    J'ai réalisé le compilateur en OCaml, en cohérence avec le langage source et l'expertise d'OCamlPro.
\end{frame}


\section{Analyse lexicale}

\AtBeginSection[]
{
  \begin{frame}{\secname}
    \tableofcontents[currentsection, hideothersubsections]
  \end{frame}
}

\begin{frame}[fragile]{Lexique}
    % Le lexique source est un sous-ensemble de celui d'OCaml pour supporter les fonctionnalités qui m'intéressent. Je n'ai pas jugé pertinent d'indiquer le nom des jetons.
    \begin{itemize}
        \item \lstinline{(* *)} pour les commentaires
        \item \lstinline{( )} pour le parenthésage
        \item \lstinline{+ -} pour les opérations sur les entiers
        \item \lstinline{if then else} pour le branchement conditionnel
        \item \lstinline{fun ->} pour la création de fermeture
        \item \lstinline{let rec = and in} pour les déclarations (mutuellement récursives)
        \item \lstinline{type of | *} pour la déclaration d'un type somme
        \item \lstinline{,} pour les constructeurs
        \item \lstinline{match with | _} pour le filtrage par motif
        \item \lstinline{['0'-'9']+} pour la déclaration d'un entier (positif)
        \item \lstinline{['A'-'Z']['a'-'z''A'-'Z''0'-'9''_']*} pour désigner un constructeur
        \item \lstinline{['a'-'z']['a'-'z''A'-'Z''0'-'9''_']*} pour désigner une variable
        \item \lstinline{[' ' '\t' '\n' '\r']} pour l'indentation et les sauts de ligne/retours chariot
    \end{itemize}
\end{frame}

\begin{frame}{Analyseur lexical}
    Les jetons de l'analyse lexicale sont générés par OCamllex.
\end{frame}

\subsection{Arbre de Syntaxe Abstraite (AST)}

La grammaire est la même que celle d'[OCaml](https://v2.ocaml.org/releases/5.0/manual/language.html) pour l'ensemble des jetons supportés.

\begin{frame}{Identificateurs}
    Le nom des variables et le nom des constructeurs sont des chaînes de caractères.

    \begin{block}{Identificateurs}
        $\mathbb{S} \coloneqq string$% (chaînes de caractères)

        $\mathbb{V} \coloneqq \mathbb{S}$% (variables)

        $\mathbb{T} \coloneqq \mathbb{S}$% (tags)
    \end{block}
\end{frame}

\begin{frame}{Filtrage par motif}
    J'ai choisi de ne supporter que l'essentiel pour ce qui est du filtrage par motif.% Contrairement à OCaml, qui autorise la déconstruction à chaque déclaration de variable, il n'est possible de déconstruire des termes que dans un filtrage par motif.
    
    \begin{block}{Filtrage par motif}
        $\text{Deconstructor} : \mathbb{T} \times \mathbb{V}^{*} \mapsto \mathbb{M}$% pour filtrer un tag.

        $\text{Joker} : \mathbb{V} \mapsto \mathbb{M}$% pour filtrer tous les cas restants.
    \end{block}
\end{frame}

\begin{frame}{Opérateurs binaires}
    Les opérateurs binaires se limitent pour l'instant aux opérations sur les entiers.

    \begin{block}{Opérateurs binaires}
        $\text{Add} : \mathbb{B}$% correspond à l'addition.

        $\text{Sub} : \mathbb{B}$% correspond à la soustraction.
    \end{block}
\end{frame}

\begin{frame}{Expressions}
    Les expressions constituent la base d'un langage fonctionnel.% Je ne réalise aucune vérification de typage, c'est pour cela que je traite les types comme de simples chaînes de caractères.

    \begin{block}{Expressions}
        $\text{Var} : \mathbb{V} \mapsto \mathbb{E}$% désigne une variable.

        $\text{Fun} : \mathbb{V} \times \mathbb{E} \mapsto \mathbb{E}$% fabrique une fermeture.

        $\text{App} : \mathbb{E} \times \mathbb{E} \mapsto \mathbb{E}$% applique une fermeture à son argument.

        $\text{Let} : \mathbb{V} \times \mathbb{E} \times \mathbb{E} \mapsto \mathbb{E}$% associe le résultat d'une expression à une variable.

        $\text{LetRec} : (\mathbb{V} \times \mathbb{E})^{*} \times \mathbb{E} \mapsto \mathbb{E}$% définit des fermetures récursives (uniquement des fermetures).

        $\text{Int} : \mathbb{Z} \mapsto \mathbb{E}$% génère un entier.

        $\text{Binop} : \mathbb{B} \times \mathbb{E} \times \mathbb{E} \mapsto \mathbb{E}$% représente une opération binaire.

        $\text{If} : \mathbb{E} \times \mathbb{E} \times \mathbb{E} \mapsto \mathbb{E}$% est le branchement conditionnel.

        $\text{Type} : \mathbb{S} \times (\mathbb{T} \times \mathbb{S})^{*} \times \mathbb{E} \mapsto \mathbb{E}$% fabrique un type (ses constructeurs).

        $\text{Constructor} : \mathbb{T} \times \mathbb{E}^{*} \mapsto \mathbb{E}$% fabrique une valeur taggée à partir d'un constructeur.

        $\text{Match} : \mathbb{E} \times (\mathbb{M} \times \mathbb{E})^{*} \mapsto \mathbb{E}$% filtre une valeur taggée.
    \end{block}
\end{frame}

\subsection{Analyseur syntaxique}

\begin{frame}{Analyseur syntaxique}
    L'AST est généré par Menhir à l'aide des jetons générés par l'analyse lexicale.
\end{frame}

\subsection{Arbre de Syntaxe Abstraite rafraîchi (AST')}

\begin{frame}{Identificateurs}
    Le nom des variables et le nom des constructeurs sont désormais représentés par des entiers naturels uniques.

    \begin{block}{Identificateurs}
        $\mathbb{V} \coloneqq \mathbb{N}$% (variables)

        $\mathbb{T} \coloneqq \mathbb{N}$% (tags)
    \end{block}
\end{frame}

\begin{frame}{Opérateurs binaires}
    Les opérateurs binaires se limitent toujours aux opérations sur les entiers.

    \begin{block}{Opérateurs binaires}
        $\text{Add} : \mathbb{B}$% correspond à l'addition.

        $\text{Sub} : \mathbb{B}$% correspond à la soustraction.
    \end{block}
\end{frame}

\begin{frame}{Expressions}
    Pour toutes les expressions, à l'exception du filtrage par motif, seul le type des identificateurs change.% Les noms des constructeurs ont reçus un index relatif à leur position dans la déclaration du type qui sera par la suite utilisé dans les filtrages par motifs.
    
    \begin{block}{Expressions}
        $\text{Var} : \mathbb{V} \mapsto \mathbb{E}$% désigne une variable.

        $\text{Fun} : \mathbb{V} \times \mathbb{E} \mapsto \mathbb{E}$% fabrique une fermeture.

        $\text{App} : \mathbb{E} \times \mathbb{E} \mapsto \mathbb{E}$% applique une fermeture à son argument.

        $\text{Let} : \mathbb{V} \times \mathbb{E} \times \mathbb{E} \mapsto \mathbb{E}$% associe le résultat d'une expression à une variable.

        $\text{LetRec} : (\mathbb{V} \times \mathbb{E})^{*} \times \mathbb{E} \mapsto \mathbb{E}$% définit des fermetures récursives (uniquement des fermetures).

        $\text{Int} : \mathbb{Z} \mapsto \mathbb{E}$% génère un entier.

        $\text{Binop} : \mathbb{B} \times \mathbb{E} \times \mathbb{E} \mapsto \mathbb{E}$% représente une opération binaire.

        $\text{If} : \mathbb{E} \times \mathbb{E} \times \mathbb{E} \mapsto \mathbb{E}$% est le branchement conditionnel.

        $\text{Constructor} : \mathbb{T} \times \mathbb{E}^{*} \mapsto \mathbb{E}$% fabrique une valeur taggée à partir d'un tag.

        $\text{Match} : \mathbb{E} \times (\mathbb{T} \times \mathbb{V}^{*} \times \mathbb{E})^{*} \times \mathbb{E} \mapsto \mathbb{E}$% filtre une valeur taggée.
    \end{block}
\end{frame}

\subsection{Rafraîchissement}

\begin{frame}{Définitions}
    $\mathbb{E}_{ast} \times \left( \mathbb{V}_{ast} \mapsto \mathbb{V} \right) \times \left( \mathbb{T}_{ast} \mapsto \mathbb{T} \right) \vdash_{\text{ast'}} \mathbb{E} \times \left( \mathbb{V} \mapsto \mathbb{V}_{ast} \right) \times \left( \mathbb{V}_{ast} \mapsto \mathbb{V} \right)$

    $e ~ A ~ C \vdash_{\text{ast'}} e' ~ S ~ L$
    \begin{itemize}
        \item $e$ est l'expression AST à compiler
        \item $A$ est la table des abstractions existantes dans l'environnement de $e$
        \item $C$ est la table des constructeurs dans l'environnement de $e$
        \item $e'$ est l'expression générée
        \item $S$ est la table des variables substituées dans $e'$
        \item $L$ est la table des variables libres de $e$
    \end{itemize}
\end{frame}

\begin{frame}{Conventions}
    Par la suite, je note $\overline{x}$ l'identifiant unique donné à une variable $x$, $e'$ l'expression générée par l'expression $e$, $\emptyset$ une table vide, $x \coloneqq y$ une entrée de table dont l'étiquette est $x$ et la valeur est $y$ et $X \sqcup Y$ l'union de deux tables. Deux tables dont les clés sont des identificateurs uniques ou des variables libres étant nécessairement disjointes, leur union est définie de manière naturelle comme l'union de leurs clés avec leurs valeurs associées.

    Il est important d'injecter les variables libres dans la table des abstractions pour éviter de détecter plusieurs fois la même variable libre.
\end{frame}

\begin{frame}{Règles}
    \begin{gather}
        \tag{Int}
        \over \left( \text{Int} ~ i \right) A ~ C \vdash_{\text{ast'}} \left( \text{Int} ~ i \right) \emptyset ~ \emptyset
     \end{gather}
     \begin{gather}
        \tag{Binop}
        \begin{split}
           e_1 ~ A ~ C &\vdash_{\text{ast'}} e_1' ~ S_{e_1} ~ L_{e_1} \\
           e_2 \left( A \sqcup L_{e_1} \right) C &\vdash_{\text{ast'}} e_2' ~ S_{e_2} ~ L_{e_2}
        \end{split}
        \over \left( \text{Binop} ~ \diamond ~ e_1 ~ e_2 \right) A ~ C \vdash_{\text{ast'}} \left( \text{Binop} ~ \diamond ~ e_1' ~ e_2' \right) \left( S_{e_1} \sqcup S_{e_2} \right) \left( L_{e_1} \sqcup L_{e_1} \right)
     \end{gather}
     \begin{gather}
        \tag{Fun}
        \begin{split}
           e \left( A \sqcup \lbrace x \coloneqq \overline{x} \rbrace \right) C &\vdash_{\text{ast'}} e' ~ S_{e} ~ L_{e}
        \end{split}
        \over \left( \text{Fun} ~ x ~ e \right) A ~ C \vdash_{\text{ast'}} \left( \text{Fun} ~ \overline{x} ~ e' \right) \left( S_{e} \sqcup \lbrace \overline{x} \coloneqq x \rbrace \right) L_{e}
     \end{gather}
     \begin{gather}
        \tag{Var1}
        \begin{split}
           x \in \mathcal{D}(A)
        \end{split}
        \over \left( \text{Var} ~ x \right) A ~ C \vdash_{\text{ast'}} \left( \text{Var} ~ A\left( x \right) \right) \emptyset ~ \emptyset
     \end{gather}
     \begin{gather}
        \tag{Var2}
        \begin{split}
           x \notin \mathcal{D}(A)
        \end{split}
        \over \left( \text{Var} ~ x \right) A ~ C \vdash_{\text{ast'}} \left( \text{Var} ~ \overline{x} \right) \emptyset ~ \lbrace x \coloneqq \overline{x} \rbrace
     \end{gather}
     \begin{gather}
        \tag{Let}
        \begin{split}
           e_1 ~ A ~ C &\vdash_{\text{ast'}} e_1' ~ S_{e_1} ~ L_{e_1} \\
           e_2 \left( A \sqcup L_{e_1} \sqcup \lbrace x \coloneqq \overline{x} \rbrace \right) C &\vdash_{\text{ast'}} e_2' ~ S_{e_2} ~ L_{e_2}
        \end{split}
        \over \left( \text{Let} ~ x ~ e_1 ~ e_2 \right) A ~ C \vdash_{\text{ast'}} \left( \text{Let} ~ \overline{x} ~ e_1' ~ e_2' \right) \left( S_{e_1} \sqcup S_{e_2} \sqcup \lbrace \overline{x} \coloneqq x \rbrace \right) \left( L_{e_1} \sqcup L_{e_2} \right)
     \end{gather}
     \begin{gather}
        \tag{If}
        \begin{split}
           e_1 ~ A ~ C &\vdash_{\text{ast'}} e_1' ~ S_{e_1} ~ L_{e_1} \\
           e_2 \left( A \sqcup L_{e_1} \right) C &\vdash_{\text{ast'}} e_2' ~ S_{e_2} ~ L_{e_2} \\
           e_3 \left( A \sqcup L_{e_1} \sqcup L_{e_2} \right) C &\vdash_{\text{ast'}} e_3' ~ S_{e_3} ~ L_{e_3}
        \end{split}
        \over \left( \text{If} ~ e_1 ~ e_2 ~ e_3 \right) A ~ C \vdash_{\text{ast'}} \left( \text{Binop} ~ e_1' ~ e_2' ~ e_3' \right) \left( S_{e_1} \sqcup S_{e_2} \sqcup S_{e_3} \right) \left( L_{e_1} \sqcup L_{e_1} \sqcup L_{e_3} \right)
     \end{gather}
     \begin{gather}
        \tag{App}
        \begin{split}
           e_1 ~ A ~ C &\vdash_{\text{ast'}} e_1' ~ S_{e_1} ~ L_{e_1} \\
           e_2 \left( A \sqcup L_{e_1} \right) C &\vdash_{\text{ast'}} e_2' ~ S_{e_2} ~ L_{e_2}
        \end{split}
        \over \left( \text{App} ~ e_1 ~ e_2 \right) A ~ C \vdash_{\text{ast'}} \left( \text{App} ~ e_1' ~ e_2' \right) \left( S_{e_1} \sqcup S_{e_2} \right) \left( L_{e_1} \sqcup L_{e_2} \right)
     \end{gather}
     \begin{gather}
        \tag{Type}
        \begin{split}
           e ~ A \left( C \sqcup \lbrace t_i \coloneqq i, i \in 1 \dots n \rbrace \right) &\vdash_{\text{ast'}} e' ~ S_{e} ~ L_{e}
        \end{split}
        \over \left( \text{Type} ~ s \left( t_i, s_i \right)_{i=1}^{i=n} ~ e \right) A ~ C \vdash_{\text{ast'}} e' ~ S_{e} ~ L_{e}
     \end{gather}
     \begin{gather}
        \tag{Constructor}
        \begin{split}
           e_1 ~ A ~ C &\vdash_{\text{ast'}} e_1' ~ S_{e_1} ~ L_{e_1} \\
           \dots \\
           e_n \left( \bigsqcup_{i=1}^{i=n-1} L_{e_{i-1}} \sqcup A \right) C &\vdash_{\text{ast'}} e_n' ~ S_{e_n} ~ L_{e_n}
        \end{split}
        \over \left( \text{Constructor} ~ s \left( e_i \right)_{i=1}^{i=n} \right) A ~ C \vdash_{\text{ast'}} \left( \text{Constructor} \left( C(s) \right) \left( e_i' \right)_{i=1}^{i=n} \right) \left( \bigsqcup_{i=1}^{i=n} S_{e_i} \right) \left( \bigsqcup_{i=1}^{i=n} L_{e_i} \right)
     \end{gather}
     \begin{gather}
        \tag{LetRec}
        \begin{split}
           e_1 \left( \lbrace x_i \coloneqq x_i', i \in 1 \dots n \rbrace \sqcup A \right) C &\vdash_{\text{ast'}} e_1' ~ S_{e_1} ~ L_{e_1} \\
           \dots \\
           e_n \left( \bigsqcup_{i=1}^{i=n-1} S_{e_{i-1}} \sqcup \lbrace x_i \coloneqq x_i', i \in 1 \dots n \rbrace \sqcup A \right) C &\vdash_{\text{ast'}} e_n' ~ S_{e_n} ~ L_{e_n}
        \end{split}
        \over \left( \text{LetRec} \left( x_i, e_i \right)_{i=1}^{i=n} ~ e \right) A ~ C \vdash_{\text{ast'}} \left( \text{LetRec} \left( x_i', e_i' \right)_{i=1}^{i=n} ~ e' \right) \left( \bigsqcup_{i=1}^{i=n} S_{e_i} \right) \left( \bigsqcup_{i=1}^{i=n} L_{e_i} \right)
     \end{gather}
     \begin{gather}
        \tag{Match}
        \begin{split}
        (todo)
        \end{split}
        \over \left( \text{Match} ~ e \left( m_i, e_i \right)_{i=1}^{i=n} \right) A ~ C \vdash_{\text{ast'}} \left( \text{Match} ~ e' \left( t_i', \left( a_i^j \right)_{j=1}^{j=m_i}, e_i' \right)_{i=1}^{i=n}\right) \left( \bigsqcup_{i=1}^{i=n} S_{e_i} \sqcup S_{e} \right) \left( \bigsqcup_{i=1}^{i=n} L_{e_i} \sqcup L_{e} \right)
     \end{gather}
\end{frame}

\section{Analyse du flot de contrôle}

%La conversion CPS/CFG transforme l'AST' en un ensemble de basic blocs. À l'origine il s'agissait d'une conversion CPS, mais l'explicitation des variables libres et la décontextualisation des blocs fait qu'aujourd'hui elle ressemble davantage à une conversion vers un CFG. L'idée est de perdre le moins d'informations possible du programme source tout en ayant sous la main une représentation intermédiaire qui permette une analyse simple et puissante.

\subsection{Graphe de flot de contrôle}

La différence notable avec l'AST' est l'apparition des blocs (avec explicitation des variables libres) et l'absence d'expressions imbriquées.

\begin{frame}{Graphe de flot de contrôle}{Identificateurs}
    On retrouve les identificateurs pour les variables et les tags, auxquels s'ajoute un identificateur pour les pointeurs.
    
    \begin{block}{Identificateurs}
        $\mathbb{V} \coloneqq \mathbb{N}$% (variables)

        $\mathbb{T} \coloneqq \mathbb{N}$% (tags)

        $\mathbb{P} \coloneqq \mathbb{N}$% (pointeurs)
    \end{block}
\end{frame}

\begin{frame}{Graphe de flot de contrôle}{Expressions}
    Les expressions correspondent aux instructions élémentaires qui construisent des valeurs.
    
    \begin{block}{Expressions}
        $\text{Int} : \mathbb{Z} \mapsto \mathbb{E}$% génère un entier.

        $\text{Var} : \mathbb{V} \mapsto \mathbb{E}$% crée un alias de variable.

        $\text{Add} : \mathbb{V} \times \mathbb{V} \mapsto \mathbb{E}$% additionne deux entiers.

        $\text{Sub} : \mathbb{V} \times \mathbb{V} \mapsto \mathbb{E}$% soustrait deux entiers.

        $\text{Closure} : \mathbb{P} \times \mathbb{V}^{*} \mapsto \mathbb{E}$% fabrique une fermeture.

        $\text{Constructor} : \mathbb{T} \times \mathbb{V}^{*} \mapsto \mathbb{E}$% fabrique une valeur taggée.
    \end{block}
\end{frame}

\begin{frame}{Graphe de flot de contrôle}{Instructions}
    Une instruction est soit une déclaration soit un branchement.% Une déclaration construit une valeur à partir d'une expression et l'associe à un identifiant unique. Les valeurs ne peuvent être construites qu'à partir de constantes ou identifiants. Un branchement représente le transfert d'un basic block à un autre que ce soit par le biais d'un appel (fermeture), d'un retour de fonction (return) ou d'un saut conditionnel (filtrage par motif). Comme chaque bloc explicite ses variables libres (arguments), celles-ci doivent apparaître dans les branchements. Les variables libres à destination de différents blocs ne sont jamais réunies afin de conserver un maximum d'informations sur leurs origines.
    
    \begin{block}{Instructions}
        $\text{Let} : \mathbb{V} \times \mathbb{E} \times \mathbb{I} \mapsto \mathbb{I}$% assigne le résultat d'une expression à une variable.

        $\text{Call} : \mathbb{V} \times \mathbb{V}^{*} \times \left( \mathbb{P} \times \mathcal{P}(\mathbb{V}) \right) \mapsto \mathbb{I}$% branche vers le bloc avec l'environnement contenu dans la fermeture puis continue l'éxécution avec le contexte spécifié.

        $\text{CallDirect} : \mathbb{P} \times \mathbb{V} \times \mathbb{V}^{*} \times \left( \mathbb{P} \times \mathcal{P}(\mathbb{V}) \right) \mapsto \mathbb{I}$% est identique à $\text{Call}$% à l'exception que le pointeur du bloc vers lequel brancher est connu suite à une étape d'analyse (cette instruction n'est par conséquent jamais générée depuis l'AST').

        $\text{If} : \mathbb{V} \times (\mathbb{P} \times \mathcal{P}(\mathbb{V})) \times (\mathbb{P} \times \mathcal{P}(\mathbb{V})) \times \mathcal{P}(\mathbb{V}) \mapsto \mathbb{I}$% branche dans le premier bloc si la valeur de la condition est différente de 0, dans le deuxième sinon. Les variables libres (dernier paramètre) sont implicitement passées aux deux branches et seront utilisées par le bloc qui sera exécuté après.

        $\text{MatchPattern} : \mathbb{V} \times (\mathbb{T} \times \mathbb{V}^{*} \times \mathbb{P} \times \mathcal{P}(\mathbb{V}))^{*} \times (\mathbb{P} \times \mathcal{P}(\mathbb{V})) \times \mathcal{P}(\mathbb{V}) \mapsto \mathbb{I}$% branche soit vers un des blocs lorsque la valeur de la condition correspond au motif de l'un d'eux, soit vers le bloc par défaut. Les variables libres (dernier paramètre) sont implicitement passées à toutes les branches et seront utilisées par le bloc qui sera exécuté après.

        $\text{Return} : \mathbb{V} \mapsto \mathbb{I}$% renvoie la valeur de cette variable au bloc appelant depuis une fermeture.

        $\text{IfReturn} : \mathbb{P} \times \mathbb{V} \times \mathcal{P}(\mathbb{V}) \mapsto \mathbb{I}$% renvoie la valeur de cette variable au bloc appelant depuis un branchement conditionnel.

        $\text{MatchReturn} : \mathbb{P} \times \mathbb{V} \times \mathcal{P}(\mathbb{V}) \mapsto \mathbb{I}$% renvoie la valeur de cette variable au bloc appelant depuis une branche d'un filtrage par motif.

        $\text{ApplyBlock} : \mathbb{P} \times \mathcal{P}(\mathbb{V}) \mapsto \mathbb{I}$% est utilisé par LetRec.
    \end{block}
\end{frame}

\begin{frame}{Graphe de flot de contrôle}{Types de blocs}
    Chaque bloc est défini différemment en fonction de l'expression à partir de laquelle il est construit.% (fermeture, retour de fonction ou saut conditionnel), est clos (il explicite les arguments dont il a besoin) et contient une suite de déclarations de variables suivies d'une instruction de branchement. Le dernier argument correspond toujours aux variables libres du bloc (environnement dans le cas d'une fermeture).
    
    \begin{block}{Types de blocs}
        $\text{Clos} : \mathbb{V}^{*} \times \mathcal{P}(\mathbb{V}) \mapsto \mathbb{B}$% est une fermeture avec ses arguments.

        $\text{Return} : \mathbb{V} \times \mathcal{P}(\mathbb{V}) \mapsto \mathbb{B}$% sera exécuté après un appel de fermeture avec comme argument son résultat.

        $\text{IfBranch} : \mathcal{P}(\mathbb{V}) \times \mathcal{P}(\mathbb{V}) \mapsto \mathbb{B}$% est un branchement conditionnel avec les variables libres qui seront passées au bloc exécuté ensuite.

        $\text{IfJoin} : \mathbb{V} \times \mathcal{P}(\mathbb{V}) \mapsto \mathbb{B}$% sera exécuté après un branchement conditionnel avec comme argument son résultat.

        $\text{MatchBranch} : \mathbb{V}^{*} \times \mathcal{P}(\mathbb{V}) \times \mathcal{P}(\mathbb{V}) \mapsto \mathbb{B}$% est un branchement d'un filtrage par motif avec ses arguments (charge du constructeur ou aucun pour le branchement par défaut) et les variables libres qui seront passées au bloc exécuté ensuite.

        $\text{MatchJoin} : \mathbb{V} \times \mathcal{P}(\mathbb{V}) \mapsto \mathbb{B}$% sera exécuté après un branchement d'un filtrage par motif avec comme argument son résultat.

        $\text{Cont} : \mathcal{P}(\mathbb{V}) \mapsto \mathbb{B}$% est utilisé par LetRec.
    \end{block}
\end{frame}

\subsection{Conversion CFG}

\begin{frame}{Définition}
    La conversion de l'AST' vers le CFG convertit une expression en une suite d'instructions et un ensemble de blocs.

    $\mathbb{E}_{ast'} \times \mathbb{V} \times \mathcal{P}(\mathbb{V}) \times \mathbb{I} \vdash_{\text{cfg}} \mathbb{I} \times \mathcal{P}(\mathbb{V}) \times (\mathbb{P} \mapsto (\mathbb{B} \times \mathbb{I}))$
\end{frame}

\begin{frame}{Explications}
    $e ~ v ~ V ~ i \vdash_{\text{cfg}} e' ~ V_e ~ B_e$
    \begin{itemize}
        \item $e$ est l'expression sous forme d'AST' à intégrer au CFG
        \item $v$ est le nom de la variable dans lequel conserver le résultat de l'évaluation de $e$
        \item $V$ est l'ensemble des variables libres (arguments) de $i$ devant être sauvegardées durant l'évaluation de $e$ pour être réstaurées après (ne doit pas contenir $v$).
        \item $i$ est l'expression déjà transpilée au format CFG qui sera éxécutée après $e$. Elle est supposée faire usage de $v$ et chaque variable libre qui y apparaît doit figurer dans $V$
        \item $e'$ est $e$ transpilée
        \item $V_e$ est l'ensemble des variables libres apparaissant dans $e$ qui ne proviennent pas de $V$. En théorie, les variables libres de $e'$ sont exactement $V \cup V_e$. À l'origne $V_e$ contenait toutes les variables libres apparaissant dans $e'$ de la même manière que $V$ contient toutes les variables libres de $i$ mais j'ai amendé cela pour simplifier l'implémentation. Cette nouvelle version est néanmoins bancale ($e'$ peut ne pas contenir $i$ mais un appel vers un bloc contenant $i$ et il est impossible de le déduire d'après $V_e$) c'est pour cela que j'ai prévu de revenir à l'ancienne version quand j'aurai la garantie qu'elle est toujours compatible
        \item $B_e$ est l'ensemble des blocs générés par la transpilation de $e$
    \end{itemize}
\end{frame}

\begin{frame}{Conventions}
    Par la suite :
    \begin{itemize}
        \item $\overline{e}$ correspond à l'identifiant unique (variable) attribué au résultat de l'évaluation de $e$
        \item $\dot{e}$ correspond à l'identifiant de code unique (pointeur)  attribué au bloc qui contiendra $e$
    \end{itemize}
\end{frame}

\begin{frame}{Règles}
    \begin{gather}
        \tag{Int}
        \over \left( \text{Int} ~ i \right) v ~ V ~ \epsilon \vdash_{\text{cfg}} \left( \text{Let} ~ v \left( \text{Int} ~ i \right) \epsilon \right) \emptyset ~ \emptyset
     \end{gather}
     \begin{gather}
        \tag{Var}
        \label{Var}
        \over \left( \text{Var} ~ x \right) v ~ V ~ \epsilon \vdash_{\text{cfg}} \left( \text{Let} ~ v ~ x ~ \epsilon \right) \lbrace x \rbrace ~ \emptyset
     \end{gather}
     \begin{gather}
        \tag{Let}
        \begin{split}
           e_2 ~ v ~ V ~ \epsilon \vdash_{\text{cfg}} e_2' ~ V_{e_2} ~ B_{e_2} \quad V_3 = V_{e_2} \setminus \lbrace x \rbrace \\
           e_1 ~ x \left( V \cup V_3 \right) e_2' \vdash_{\text{cfg}} e_1' ~ V_{e_1} ~ B_{e_1}
        \end{split}
        \over \left( \text{Let} ~ x ~ e_1 ~ e_2 \right) v ~ V ~ \epsilon \vdash_{\text{cfg}} e_1' \left( V_3 \cup V_{e_1} \right) \left( B_{e_1} \sqcup B_{e_2} \right)
     \end{gather}
     \begin{gather}
     \tag{Binop}
        \begin{split}
           e_2 ~ \overline{e_2} \left( V \cup \lbrace \overline{e_1} \rbrace \right) (v = \overline{e_1} \diamond \overline{e_2}; \epsilon) &\vdash_{\text{cfg}} e_2' ~ V_{e_2} ~ B_{e_2} \\
           e_1 ~ \overline{e_1} ~ (V_{e_2} \cup V) ~ e_2' &\vdash_{\text{cfg}} e_1' ~ V_{e_1} ~ B_{e_1}
        \end{split}
        \over \left( \text{Binop} ~ \diamond ~ e_1 ~ e_2 \right) v ~ V ~ \epsilon \vdash_{\text{cfg}} e_1' \left( V_{e_1} \cup V_{e_2} \right) \left( B_{e_1} \sqcup B_{e_2} \right)
     \end{gather}
     \begin{gather}
        \tag{Fun}
        \begin{split}
           e ~ \overline{e} ~ \emptyset \left( \text{Return} ~ \overline{e} \right) \vdash_{\text{cfg}} e' ~ V_{e} ~ B_{e} \quad V_2 = V_{e} \setminus \lbrace x \rbrace
        \end{split}
        \over \left( \text{Fun} ~ x ~ e \right) v ~ V ~ \epsilon \vdash_{\text{cfg}} \left( \text{Let} ~ v \left( \text{Closure} ~ \dot{e} ~ V_2 \right) \epsilon \right) V_2 \left( B_{e} \sqcup \lbrace \dot{e} = \text{Clos} \left( x \right) V_2 ~ e' \rbrace \right)
     \end{gather}
     \begin{gather}
        \tag{If}
        \begin{split}
           e_2 ~ \overline{e_2} ~ V ~ (\text{Ifreturn} ~ \dot{e_1} ~ \overline{e_2} ~ V) &\vdash_{\text{cfg}} e_2' ~ V_{e_2} ~ B_{e_2} \\
           e_3 ~ \overline{e_3} ~ V ~ (\text{Ifreturn} ~ \dot{e_1} ~ \overline{e_3} ~ V) &\vdash_{\text{cfg}} e_3' ~ V_{e_3} ~ B_{e_3} \\
           e_1 ~ \overline{e_1} ~ (V \cup V_{e_2} \cup V_{e_3}) ~ (\text{If} ~ \overline{e_1} ~ \dot{e_2} ~ V_{e_2} ~ \dot{e_3} ~ V_{e_3} ~ V) &\vdash_{\text{cfg}} e_1' ~ V_{e_1} ~ B_{e_1} \\
           B_{e_1e_2e_3} = \lbrace \dot{e_1} = \text{Ifjoin} ~ v ~ V ~ \epsilon, \dot{e_2} = \text{Ifbranch} ~ V_{e_2} ~ V ~ e_2', \dot{e_3} = \text{Ifbranch} ~ V_{e_3} ~ V ~ e_3' \rbrace
        \end{split}
        \over (\text{If} ~ e_1 ~ e_2 ~ e_3) ~ v ~ V ~ \epsilon \vdash_{\text{cfg}} e_1' ~ (V_{e_1} \cup V_{e_2} \cup V_{e_3}) \left( B_{e_1} \sqcup B_{e_2} \sqcup B_{e_3} \sqcup B_{e_1e_2e_3} \right)
     \end{gather}
     \begin{gather}
        \tag{App}
        \begin{split}
           e_2 ~ \overline{e_2} \left( V \cup \lbrace \overline{e_1} \rbrace \right) \left( \text{Call} ~ \overline{e_1} \left( \overline{e_2} \right) \dot{e} ~ V \right) &\vdash_{\text{cfg}} \epsilon_2 ~ V_{e_2} ~ B_{e_2} \\
           e_1 ~ \overline{e_1} \left( V_{e_2} \cup V \right) \epsilon_2 &\vdash_{\text{cfg}} \epsilon_1 ~ V_{e_1} ~ B_{e_1}
        \end{split}
        \over \left( \text{App} ~ e_1 ~ e_2 \right) v ~ V ~ \epsilon \vdash_{\text{cfg}} \epsilon_2 \left( V_{e_1} \cup V_{e_2} \right) \left( B_{e_1} \sqcup B_{e_2} \sqcup \lbrace \dot{e} = \text{Return} ~ v ~ V ~ \epsilon \rbrace \right)
     \end{gather}
     \begin{gather}
        \tag{Constructor}
        \begin{cases}
           \epsilon_0, V_0, B_0 = \text{Let} ~ v \left( \text{Constructor} ~ t \left( \overline{a_i} \right)_{i=1}^{i=n} \right) \epsilon, \lbrace \overline{a_i} \mid 1 \leq i \leq n \rbrace, \emptyset \\
           \epsilon_n, V_n, B_n = \epsilon, V \cup V_{n-1}, B \cup B_{n-1} \text{ si } a_n ~ \overline{a_n} \left( V \cup V_{n-1} \setminus \lbrace \overline{a_n} \rbrace \right) \epsilon_{n-1} \vdash_{\text{cfg}} \epsilon ~ V ~ B \\
        \end{cases}
        \over \left( \text{Constructor} ~ t \left( a_i \right)_{i=1}^{i=n} \right) v ~ V ~ \epsilon \vdash_{\text{cfg}} \epsilon_n ~ V_n ~ B_n
     \end{gather}
     \begin{gather}
        \tag{Match}
        \begin{split}
           d ~ \overline{d} ~ V ~ (\text{Matchreturn} ~ \dot{\epsilon} ~ \overline{d} ~ V) \vdash_{\text{cfg}} \epsilon_d ~ V_d ~ B_d \\
           \begin{cases}
              B_0 = \emptyset \\
              \begin{split}
              V_{e_n}, B_n = V, B \cup B_{n-1} \cup \lbrace \dot{e_n}, \text{Matchbranch} \left( \overline{a_n^i} \right)_{i=1}^{i=m_n} V_{e_n} ~ V, \epsilon \rbrace \\ \text{ si } e_n ~ \overline{e_n} ~ V ~ (\text{Matchreturn} ~ \dot{\epsilon} ~ \overline{e_n} ~ V) \vdash_{\text{cfg}} \epsilon ~ V ~ B \\
              V_{e_n} = V_{e_n} \setminus \lbrace a_n^1, \dots, a_n^{m_n} \rbrace
              \end{split}
           \end{cases} \\
           { V_{e_n} =
           e_n ~ \overline{e_n} ~ V ~ (\text{Matchreturn} ~ \dot{\epsilon} ~ \overline{e_n} ~ V) \vdash_{\text{cfg}} \epsilon ~ V ~ B
           \over V \setminus \lbrace a_n^1, \dots, a_n^{m_n} \rbrace } \\
           e ~ \overline{e} \left( \bigcup_{i=1}^{i=n} V_{e_i} \cup V_d \cup V \right) \left( \text{Matchpattern} ~ \overline{e} \left( t_i, \dot{e_i}, \left( \overline{a_i^j} \right)_{j=1}^{j=m_i}, V_{e_i} \right)_{i=1}^{i=n} \langle \dot{d}, V_d \rangle ~ V \right) \vdash_{\text{cfg}} \epsilon_1 ~ V_1 ~ B_1
        \end{split}
        \over (\text{Match} ~ e \left( t_i, \left( a_i^j \right)_{j=1}^{j=m_i}, e_i \right)_{i=1}^{i=n} d) ~ v ~ V ~ \epsilon \vdash_{\text{cfg}} (todo)
     \end{gather}
\end{frame}

\begin{frame}{Nettoyage des alias}
    Le code CFG ainsi généré est susceptible de contenir de nombreux alias de variables (créés par la règle $\eqref{Var}$). La passe de nettoyage supprime tous les alias. Il est plus simple d'éliminer les alias en 2 passes que directement lors de la génération même si cela permettrait de se passer de l'expression $\text{Var}$ dans la représentation intermédiaire.
\end{frame}

\begin{frame}{Taille}
    Déterminer la taille du CFG est nécessaire pour certaines heuristiques. Comme le CFG n'est pas le langage qui sera compilé ou exécuté, le calcul de cette taille est seulement indicatif et n'est en aucun cas précis. La taille du CFG correspond à la somme de la taille de tous ses blocs. La taille d'un bloc correspond au nombre de ses paramètres plus la somme de la taille de ses instructions. La taille d'une instruction dépend principalement du nombre de ses arguments.
\end{frame}

\begin{frame}{Recensement des variables et appels de blocs}
    Plusieurs optimisations ont besoin de connaître la vivacité des variables et blocs. L'approche naïve que j'ai implémentée consiste simplement à compter leurs occurences. Cela permet d'éliminer un nombre conséquant de variables et blocs morts avec la garantie de ne jamais éliminer quoi que ce soit de vivant mais ne permet pas d'éliminer tout ce qui est réellement mort. Une analyse plus efficace est souhaitable mais difficile à implémenter pour le peu de bénéfice que cela apporterait.
\end{frame}

\subsection{Spécialisation}

%La spécialisation consiste à copier des blocs. Les appels directs vers les blocs concernés reçoivent un nouveau pointeur vers un bloc fraîchement copié. La copie d'un bloc a pour effet immédiat d'améliorer la précision de l'analyse, et c'est également la première étape de l'inlining.

\begin{frame}{Spécialisation}
    %L'implémentation actuelle de la spécialisation des blocs n'est pas poussée à son maximum. Les blocs à copier sont toujours copiés indépendamment de l'appel. Il serait intéressant d'intégrer la possibilité de choisir les appels à spécialiser, autrement dit de traiter des couples bloc appelant/bloc appelé. Néammoins un tel couple me paraîtrait insuffisant notamment lorsqu'un même bloc peut être appelé de différentes manières par une même instruction (en théorie c'est le cas du filtrage par motif même si mon implémentation actuelle ne le permet pas). Une solution possible serait de choisir dynamiquement lors de l'analyse de spécialiser tel ou tel appel. Cette solution apporterait certes des réponses mais apporterait probablement de trop nombreux problèmes.

    %Lors de la copie d'un bloc il est évidemment indispensable de conserver les invariants qui s'appliquent au CFG, en particulier l'unicité des noms de variable, c'est pour cela que chaque copie s'accompagne d'une nouvelle étape de renommage.

    La spécialisation consiste à dupliquer des blocs.

    \begin{itemize}
        \item Améliore la précision de l'analyse
        \item Première étape de l'inlining
    \end{itemize}

    La copie doit :

    \begin{itemize}
        \item Conserver les invariants du CFG
        \item Modifier les appels directs
    \end{itemize}

    Les blocs sont choisis selon leur taille.
\end{frame}


\begin{frame}{Algorithme de spécialisation}
    %L'implémentation actuelle de la spécialisation des blocs n'est pas poussée à son maximum. Les blocs à copier sont toujours copiés indépendamment de l'appel. Il serait intéressant d'intégrer la possibilité de choisir les appels à spécialiser, autrement dit de traiter des couples bloc appelant/bloc appelé. Néammoins un tel couple me paraîtrait insuffisant notamment lorsqu'un même bloc peut être appelé de différentes manières par une même instruction (en théorie c'est le cas du filtrage par motif même si mon implémentation actuelle ne le permet pas). Une solution possible serait de choisir dynamiquement lors de l'analyse de spécialiser tel ou tel appel. Cette solution apporterait certes des réponses mais apporterait probablement de trop nombreux problèmes.

    Lors de la copie d'un bloc il est évidemment indispensable de conserver les invariants qui s'appliquent au CFG, en particulier l'unicité des noms de variable, c'est pour cela que chaque copie s'accompagne d'une nouvelle étape de renommage.
\end{frame}

\begin{frame}{Choix des blocs à spécialiser}
    Les blocs à spécialiser sont actuellement sélectionnés uniquement si leur taille se trouve ou non sous un certain seuil statique. C'est en particulier sur ces choix que je vais être amené à trouver des heuristiques pertinentes d'ici la fin du stage. De telles heuristiques devraient prendre en compte les gains et coûts potentiels apportés par la spécialisation en se basant sur les informations issues de l'analyse.
\end{frame}

\subsection{Analyse de valeurs par interprétation abstraite}

L'analyse est l'étape la plus compliquée et probablement la plus importante pour permettre d'inliner de manière efficace. L'objectif principal est de transformer au mieux les sauts indirects (appels de fonctions) en sauts directs afin d'être capable d'inliner de tels sauts. Ensuite, même si ce n'est pas obligatoire, il est intéressant de disposer d'une analyse des valeurs assez précise pour se faire une idée de quand inliner pour obtenir les meilleurs bénéfices. Cette analyse s'effectue au niveau du CFG afin d'exploiter la sémantique du langage (en conservant certaines relations) tout en disposant des informations nécessaires sur les blocs.

Une contrainte importante portée sur l'analyse est la nécessité de pouvoir réaliser plusieurs analyses consécutives afin de pouvoir comparer les performances et résultats d'une seule analyse en profondeur face à plusieurs petites analyses. Cela implique que le langage intermédiaire sur lequel s'effectue l'analyse (en l'occurence ici le CFG) doit rester le même après analyse. C'est pour cette raison que les résultats éventuels de l'analyse, en particulier les sauts directs, sont intégrés au CFG.

\subsubsection{Domaine des points d'allocation}

Sur conseil de mon tuteur, je réalise une analyse par point d'allocation. Ce choix donne des garanties de terminaison (le nombre de point d'allocation est borné par la taille du programme) tout en permettant une analyse poussée qui autorise par exemple la récursivité lors de la construction des blocs (fondamental pour traiter les listes).

\begin{frame}{Point d'allocation}
    Un point d'allocation correspond simplement à une déclaration, c'est à dire une instruction $\text{Let}$ du CFG. Étant donné que chaque valeur créée est déclarée (il n'existe pas de valeur temporaire) avec un nom de variable unique (garanti par le rafraîchissement), un point d'allocation peut donc être identifé par le nom de variable utilisé par $\text{Let}$. 
\end{frame}

\begin{frame}{Usine}
    L'usine correspond à une table associant chaque point d'allocation aux valeurs qui y ont été produites. Par valeurs il faut comprendre valeur abstraite qui sera définie plus loin.

    $\mathbb{U} \coloneqq \mathbb{V} \mapsto \mathbb{A}$ (usine)
\end{frame}

\subsubsection{Domaines}

Actuellement seulement trois domaines abstraits sont nécessaires pour représenter toutes les valeurs du langage.

\begin{frame}{Entiers}
    Les entiers sont représentés de la manière la plus simple qui soit, c'est à dire des singletons munis de Top.
    
    \begin{block}{Abstraction}
        $\text{Top} : \mathbb{I}$

        $\text{Singleton} : \mathbb{Z} \mapsto \mathbb{I}$
    \end{block}

    L'union de deux entiers donne toujours Top sauf lorsqu'il s'agit de deux singletons de même valeur.

    \begin{block}{Union}
        $$
        x \sqcup y =
        \begin{cases}
            \text{Singleton} ~ i \text{ si } x = y = \text{Singleton} ~ i  \\
            \text{Top} \text{ sinon}
        \end{cases}
        $$
    \end{block}
\end{frame}

\begin{frame}{Fermetures}
    Le domaine pour les fermetures est un environnement d'identifiant vers contexte, où l'identifiant correspond au pointeur de fonction, et le contexte correspond aux variables libres.
    \begin{block}{Abstraction}
        $\mathbb{F} \coloneqq \mathbb{P} \mapsto \mathcal{P}(\mathcal{P}(\mathbb{V}))$ (fermeture)
    \end{block}

    L'union de deux fermetures consiste à conserver les entrées distinctes et d'unir les points d'allocations des entrées communes.% Deux entrées communes, c'est à dire ayant comme clé le même pointeur, sont censées avoir le même environnement, dans le cas contraire il s'agit d'une erreur d'implémentation.
    
    \begin{block}{Union}
        $$
        x \sqcup y = z \rightarrow
        \begin{cases}
            \lbrace x(z)(i) \cup y(z)(i), i \in x(z) \text{ et } i \in y(z) \rbrace \text{ si } z \in \mathcal{D}(x) \text{ et } z \in \mathcal{D}(y) \\
            x(z) \text{ si } z \in \mathcal{D}(x) \\
            y(z) \text{ si } z \in \mathcal{D}(y)
        \end{cases}
        $$
    \end{block}
\end{frame}

\begin{frame}{Unions taggées}
    Le domaine pour les unions taggées est un environnement d'identifiant vers contexte, où l'identifiant correspond au tag, et le contexte correspond au contenu de l'union.

    \begin{block}{Abstraction}
        $\mathbb{C} \coloneqq \mathbb{T} \mapsto \mathcal{P}(\mathbb{V})^{*}$ (union taggée)
    \end{block}

    L'union de deux valeurs taggées consiste à conserver les entrées distinctes et d'unir les points d'allocations des entrées communes.% Deux entrées communes, c'est à dire ayant comme clé le même tag, sont censées avoir le même contenu, dans le cas contraire il s'agit d'une erreur d'implémentation.
    
    \begin{block}{Union}
        $$
        x \sqcup y = z \rightarrow
        \begin{cases}
            \left( x(z)_i \cup y(z)_i \right)_{i=1}^{i=n} \text{ si } z \in \mathcal{D}(x) \text{ et } z \in \mathcal{D}(y) \text{ et } |x(z)| = |y(z)| = n \\
            x(z) \text{ si } z \in \mathcal{D}(x) \\
            y(z) \text{ si } z \in \mathcal{D}(y)
        \end{cases}
        $$
    \end{block}
\end{frame}



\subsubsection{Valeur abstraite}

\begin{frame}{Valeur abstraite}
    Une valeur abstraite est un entier, une fermeture ou une valeur taggée.

    \begin{block}{Abstraction}
        $\text{IntDomain} : \mathbb{I} \mapsto \mathbb{A}$

        $\text{ClosureDomain} : \mathbb{F} \mapsto \mathbb{A}$

        $\text{ConstructorDomain} : \mathbb{C} \mapsto \mathbb{A}$
    \end{block}
\end{frame}

\subsubsection{Blocs}

\begin{frame}{Blocs}
    Les blocs utilisés pour l'analyse sont les même que ceux du CFG à l'exception des paramètres qui sont désormais des ensembles de points d'allocation au lieu d'un nom de variables, c'est à dire $\mathbb{B}_{cfg}$ avec $\mathbb{V} \coloneqq \mathcal{P}(\mathbb{V})$. L'union de deux blocs (de même type) est l'union de leurs paramètres.
\end{frame}

\subsubsection{Abstraction de la pile}

\begin{frame}{Abstraction de la pile}
    Un contexte d'appel correspond à un étage de la pile, c'est à dire le pointer vers un bloc qui sera exécuté au prochain retour d'appel avec les paramètres qui ont été sauvegardés. La pile d'appel est une liste ordonnée de contextes d'appel.

    $\mathbb{S} \coloneqq (\mathbb{P} \times \mathcal{P}(\mathbb{V})^{*})^{*}$ (pile)

    Pour assurer la terminaison de l'analyse, il est nécessaire de disposer d'une fonction qui réduit la taille de la pile dont l'image est finie. Son intérêt est de garantir la terminaison de l'analyse en bornant le nombre de piles possibles par rapport à la taille du programme.
\end{frame}

\begin{frame}{Abstraction de la pile}{Détection de motif}
    Afin de tenter d'obtenir une précision maximale, je détecte d'éventuels motifs sur la pile en regardant si des contextes d'appels se répètent et le cas échéant je supprime la répétition.% Par exemple la pile d'appels `ABCBC` a un motif `BC` de taille 2 et sera remplacée par `ABC`.% Néanmoins mes tuteurs m'ont fait comprendre qu'elle ne pouvait pas garantir la terminaison, certains piles peuvent croître indéfiniment sans jamais appercevoir de motif.

    \begin{exampleblock}{Exemple}
        ABCBC a un motif BC de taille 2 et sera remplacée par ABC
    \end{exampleblock}
\end{frame}

\begin{frame}{Abstraction de la pile}{n-CFA}
    n-CFA consiste à conserver les n derniers contextes de la pile.% Par exemple en 1-CFA, la pile d'appels `ABCBC` sera remplacée par `C`.

    \begin{exampleblock}{Exemple}
        En 1-CFA, la pile d'appels ABCBC sera remplacée par C
    \end{exampleblock}
\end{frame}



\subsubsection{Algorithme d'analyse}

\begin{frame}{Définitions}
    L'algorithme d'analyse prend une liste des blocs à analyser (pointeur, en-tête, pile et usine), une fonction d'abstraction de la pile, l'ensemble des blocs du programme, l'ensemble des usines pour chaque contexte de chaque bloc déjà analysé et renvoie en-tête et usine pour chaque bloc.

    $\text{analyse} : (\mathbb{P} \times \overline{\mathbb{B}} \times \mathbb{S} \times \mathbb{U})^{*} \times (\mathbb{S} \mapsto \mathbb{S}) \times (\mathbb{P} \mapsto \mathbb{B}) \times (\mathbb{P} \mapsto ((\mathbb{S} \times \overline{\mathbb{B}}) \mapsto \mathbb{U})) \mapsto (\mathbb{P} \mapsto (\overline{\mathbb{B}} \times \mathbb{U}))$

    L'analyse d'un bloc se fait par la fonction $`analyse_de_bloc`$ qui à partir d'un bloc, d'une pile, d'un environnement et d'une usine renvoie une liste de blocs à analyser.

    $`env_de_bloc`$ est une fonction qui génère l'environnement à partir de l'en-tête d'un bloc et les valeurs abstraites qui lui sont passées.
\end{frame}

\begin{frame}{Algorithme}
    \begin{algorithm}[H]
        \DontPrintSemicolon
        \SetAlgoLined
        \SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
        \Input{l pile\_abs B U}
        \BlankLine
        \tcp{Il ne reste plus aucun bloc à analyser.}
        \eIf{l est vide}{
           \Return $U$ telle que pour chaque bloc sa valeur soit l'union des usines et paramètres de chaque contexte de pile de ce bloc. \tcp{Tous les contextes de pile sont fusionnés.}
        }{
           $p, b, s, u \gets \text{hd}(l)$ \tcp{Le premier bloc à analyser.}
           $l' \gets \text{tl}(l)$ \tcp{Les autres blocs à analyser.}
           $\overline{s} \gets \text{pile\_abs}(s)$ \tcp{Abstraction de la pile.}
           $c \gets (\overline{s}, b)$ \tcp{Le contexte (pile et en-tête).}
        
           \BlankLine
           \tcp{Ce bloc a déjà été analysé.}
           \eIf{$p \in \mathcal{D}(U)$}{
              $U_p \gets U[p]$ \tcp{Les usines associées à ce bloc.}
              
              \BlankLine
              \tcp{Ce contexte a déjà été analysé pour ce bloc.}
              \eIf{$c \in \mathcal{D}(U_p)$}{
                 $u_c \gets U_p$[c] \tcp{L'usine associée à ce contexte.}
                 $u_2 \gets u_c \cup u$ \tcp{Union de l'ancienne et la nouvelle usine.}
        
                 \BlankLine
                 \tcp{L'ancienne usine et la nouvelle ont convergé.}
                 \eIf{$u_2 = u_c$}{
                    \BlankLine
                    \tcp{La pile d'appels est vide.}
                    \eIf{s est vide}{
                       \Return{analyse(l', pile\_abs, B, U)} \tcp{On continue avec les prochains blocs.}
                    }{
                       $p_2, args \gets hd(s)$ \tcp{Le contexte vers lequel renvoyer.}
                       $s_3 \gets tl(s)$ \tcp{Les autres blocs à analyser.}
                       $b_2 \gets \text{Return}(\emptyset, args)$ \tcp{Le bloc de retour recevra Bottom.}
        
                       \BlankLine
                       \Return{$\text{analyse}((p_2, b_2, s_3, u_2) :: l', \text{pile\_abs}, B, U)$} \tcp{On analysera le bloc appelant avec Bottom comme résultat.}
                    }
                 }{
                    $b_2, i \gets B(p)$ \tcp{L'en-tête et le corps de ce bloc.}
                    $l_2 \gets \text{analyse\_de\_bloc}(i, s, \text{env\_de\_bloc}(b_2, b), u_2)$ \tcp{On analyse ce bloc et on récupère les prochains à analyser.}
        
                    $U_p[c] \gets u_2$ \tcp{On met à jour l'usine pour ce contexte.}
                    $U[$p$] \gets U_p$ \tcp{On met à jour les usines pour ce bloc.}
        
                    \BlankLine
                    \Return {$\text{analyse}(l' @ l_2, \text{pile\_abs}, B, U)$} \tcp{Récursion sur les nouveaux blocs à analyser.}
                 }
              }{
                 \tcc{Page suivante}
              }
           }{
              \tcc{Page suivante}
           }
        }
        \caption{Analyse du programme}
    \end{algorithm}
\end{frame}

\begin{frame}{Terminaison}
    %Les identifiants de variable ou de bloc (pointeur) sont en nombre fini dans le code et ne sont jamais générés lors de l'analyse, leur nombre est donc borné par la taille du programme. Chaque point d'allocation étant une variable, un ensemble de points d'allocations est par conséquent également borné par la taille du programme. L'union de deux entiers converge évidemment vers un point fixe. Étant donné que les pointeurs, les tags ainsi que les ensembles de points d'allocations sont des ensembles bornés par la taille du programme, l'union de deux fermetures ou de deux valeurs taggées est garantie de converger vers un point fixe. Il en est de même pour l'union de deux usines qui pour un ensemble fini de point d'allocation attribue des valeurs dont l'union converge. L'abstraction de la pile d'appels quant à elle est censée garantir que celle-ci ne croisse pas infiniment, ce qui borne le nombre de contexte d'appel pour chaque bloc. Même s'il ne s'agit pas d'une preuve formelle, tous ces arguments semblent confirmer que l'analyse est garantie de terminer.
    
    Quelques idées justifiant la terminaison de l'analyse.

    \begin{itemize}
        \item Identifiants jamais générés
        \item Un point d'allocation est un identifiant
        \item L'union de deux valeurs converge
        \item L'union de deux usines converge
        \item Abstraction de la pile d'appels
    \end{itemize}
\end{frame}

\subsubsection{Propagation}

%La propagation modifie le CFG pour y faire apparaître les résultats de l'analyse. Avec le recul, il est fort probable que cette optimisation ne soit pas strictement nécessaire à cette étape de la compilation, mais se fasse plutôt lors de la conversion vers le CFG exécutable (c'est à dire générer le CFG exécutable en ayant sous la main les résultats de l'analyse au lieu de modifier le CFG sur lequel il existe des contraintes sémantique fortes).

\begin{frame}{Propagation}
    La propagation modifie le CFG pour y faire apparaître les résultats de l'analyse.

    \begin{itemize}
        \item Expressions transformées en constantes
        \item Éliminations de branches
        \item Appels indirects transformés en appels directs
    \end{itemize}
\end{frame}

\begin{frame}{Propagation}{Constantes}
    Lorsque les paramètres sont connus, certaines expressions comme l'addition ou la soustraction sont transformées en constantes.
\end{frame}

\begin{frame}{Propagation}{Branchements conditionnels}
    Lorsque les valeurs possibles de la condition d'un if ou d'un filtrage par motif sont connues, certaines branches sont supprimées. Néanmoins pour respecter la sémantique des blocs, il n'est pas possible durant cette phase de transformer les branchements en appels directs lorsqu'il ne reste qu'une seule branche possible.
\end{frame}

\begin{frame}{Propagation}{Appels indirects}
    Les appels indirects sont transformés en appels directs lorsqu'il y a exactement 1 fermeture candidate.
\end{frame}

L'objectif principal de ce langage intermédiaire est d'avoir une représentation bas-niveau stable et facile à interpréter sur laquelle effectuer des benchmarks. L'inlining a lieu sur le CFG exécutable car les modifications apportées peuvent casser la sémantique d'appel ce qui doit être représenté au niveau de la pile.

\subsection{Langage}

Le CFG exécutable est très similaire au CFG, si ce n'est que quasiment tous les traits de langage propres à OCaml ont été concrétisés. À chaque construction de valeur du langage OCaml est associée une structure de données, la plupart d'entre elles devenant des n-uplets. Tous les types de blocs fusionnent en un seul en fixant la sémantique des sauts (passage de l'environnement comme argument) et chaque type de branchement est transformé en un saut (direct ou indirect) avec la possibilité d'ajouter des contextes d'appel sur la pile (seule l'instruction d'appel ajoute un contexte lors de cette transformation).

\begin{frame}{CFG exécutable}{Identifiants}
    On retrouve ici les identifiants du CFG auxquels s'ajoutent de nouveaux identifiants pour gérer les contextes de pile.
    
    \begin{block}{Identifiants}
        $\mathbb{V} \coloneqq \mathbb{N}$% (variables)
        
        $\mathbb{P} \coloneqq \mathbb{N}$% (pointeurs de blocs)
        
        $\mathbb{F} \coloneqq \mathbb{P} \times \mathbb{V}^{*}$% (contexte d'appel)
        
        $\mathbb{S} \coloneqq \mathbb{F}^{*}$% (pile)
    \end{block}
\end{frame}

\begin{frame}{CFG exécutable}{Expressions}
    De la même manière que pour les identifiants, on retrouve ici la plupart des expressions du CFG. Le principal changement est la transformation des constructeurs et fermetures qui deviennent des n-uplets.
    
    \begin{block}{Expressions}
        $\text{Const} : \mathbb{Z} \mapsto \mathbb{E}$% génère un entier.
        
        $\text{Pointer} : \mathbb{P} \mapsto \mathbb{E}$% génère un pointeur vers un bloc.
        
        $\text{Var} : \mathbb{V} \mapsto \mathbb{E}$% crée un alias de variable.
        
        $\text{Add} : \mathbb{V} \times \mathbb{V} \mapsto \mathbb{E}$% additionne deux entiers.
        
        $\text{Sub} : \mathbb{V} \times \mathbb{V} \mapsto \mathbb{E}$% soustrait deux entiers.
        
        $\text{Tuple} : \mathbb{V}^{*} \mapsto \mathbb{E}$% fabrique un n-uplet.
        
        $\text{Get} : \mathbb{V} \times \mathbb{N} \mapsto \mathbb{E}$% accède à un champs d'un n-uplet.
    \end{block}
\end{frame}

\begin{frame}{CFG exécutable}{Instructions}
    Les instructions sont assez similaires, si ce n'est que les branchements permettent désormais d'ajouter des contextes de piles. Le filtrage par motif et le if classique fusionnent en une seule instruction.
    
    \begin{block}{Instructions}
        $\text{Let} : \mathbb{V} \times \mathbb{E} \times \mathbb{I} \mapsto \mathbb{I}$% assigne le résultat d'une expression à une variable.
        
        $\text{ApplyDirect} : \mathbb{P} \times \mathbb{V}^{*} \times \mathbb{S} \mapsto \mathbb{I}$% réalise un saut direct vers le bloc associé.
        
        $\text{ApplyIndirect} : \mathbb{V} \times \mathbb{V}^{*} \times \mathbb{S} \mapsto \mathbb{I}$% réalise un saut indirect au bloc associé au pointeur contenu dans la variable.
        
        $\text{If} : \mathbb{V} \times (\mathbb{N} \times \mathbb{P} \times \mathbb{V}^{*})^{*} \times (\mathbb{P} \times \mathbb{V}^{*}) \times \mathbb{S} \mapsto \mathbb{I}$% réalise un saut vers le bloc associé à la valeur de la condition ou vers le bloc par défaut.
        
        $\text{Return} : \mathbb{V} \mapsto \mathbb{I}$% renvoie le résultat contenu dans la variable.
    \end{block}
\end{frame}

\begin{frame}{CFG exécutable}{Bloc}
    Il n'existe plus de sémantique pour chaque type de bloc, l'ordre des arguments est maintenant fixé.
    
    \begin{block}{Bloc}
        $\mathbb{B} \coloneqq \mathbb{V}^{*} \times \mathbb{I}$% (bloc)
    \end{block}
\end{frame}

\subsection{Génération du CFG exécutable}

\begin{frame}{Définitions}
    La transpilation d'un bloc CFG peut générer plusieurs blocs concrêtisés.

    $\mathbb{B}_{cfg} \times \mathbb{I} \vdash_{\text{cfg'}} \mathbb{B} \times (\mathbb{P} \mapsto \mathbb{B})$

    $a ~ i \vdash_{\text{cfg'}} a' ~ i' ~ B$

    - $b$ est l'entête du bloc à transpiler ;
    - $i$ est l'instruction du bloc à transpiler (son contenu) ;
    - $a'$ est l'entête transpilée (les arguments du bloc transpilé) ;
    - $i'$ est le contenu transpilé ;
    - $B$ est l'ensemble des blocs générés au passage.

    Dans la suite, les ensembles de variables correspondant aux arguments des blocs sont considérés comme ordonnés (ordre lexicographique par exemple) de manière déterministe.
\end{frame}

\begin{frame}{Règles}
    \begin{gather}
        \tag{Cont}
        \over \left( \text{Cont} \left( a_i \right)_{i=0}^{i=n} \right) i \vdash_{\text{cfg'}} \left( a_i \right)_{i=0}^{i=n} ~ i ~ \emptyset
    \end{gather}
    \begin{gather}
        \tag{Return}
        \over \left( \text{Return} ~ a_0 \left( a_i \right)_{i=1}^{i=n} \right) i \vdash_{\text{cfg'}} \left( a_i \right)_{i=0}^{i=n} ~ i ~ \emptyset
    \end{gather}
    \begin{gather}
        \tag{Clos}
        \begin{cases}
           i_0 = \text{ApplyDirect} ~ p \left( a_{n+1}, \dots, a_m, a_1, \dots, a_n \right) \left( \right) \\
           i_n = \left( a_n = \text{Get} ~ e ~ n; i_{n-1} \right)
        \end{cases}
        \over \left( \text{Clos} \left( a_i \right)_{i=0}^{i=n} \left( a_i \right)_{i=n+1}^{i=m} \right) i \vdash_{\text{cfg'}} \left( e, a_{n+1}, \dots, a_m \right) i_n ~ \lbrace p = \left( a_{n+1}, \dots, a_m, a_1, \dots, a_n \right), i \rbrace
    \end{gather}
    \begin{gather}
        \tag{IfBranch}
        \over \left( \text{IfBranch} \left( a_i \right)_{i=0}^{i=n} \left( a_i \right)_{i=n+1}^{i=m} \right) i \vdash_{\text{cfg'}} \left( a_i \right)_{i=0}^{i=m} ~ i ~ \emptyset
    \end{gather}
    \begin{gather}
        \tag{IfJoin}
        \over \left( \text{IfJoin} ~ a_0 \left( a_i \right)_{i=1}^{i=n} \right) i \vdash_{\text{cfg'}} \left( a_i \right)_{i=0}^{i=n} ~ i ~ \emptyset
    \end{gather}
    \begin{gather}
        \tag{MatchBranch}
        \begin{cases}
           i_0 = i \\
           i_n = \left( a_n = \text{Get} ~ e ~ n; i_{n-1} \right)
        \end{cases}
        \over \left( \text{MatchBranch} \left( a_i \right)_{i=0}^{i=n} \left( a_i \right)_{i=n+1}^{i=m} \left( a_i \right)_{i=m+1}^{i=o} \right) i \vdash_{\text{cfg'}} \left( e, a_{n+1}, \dots, a_m, a_{m+1}, \dots, a_o \right) i_n ~ \emptyset
    \end{gather}
    \begin{gather}
        \tag{MatchJoin}
        \over \left( \text{MatchJoin} ~ a_0 \left( a_i \right)_{i=1}^{i=n} \right) i \vdash_{\text{cfg'}} \left( a_i \right)_{i=0}^{i=n} ~ i ~ \emptyset
    \end{gather}
\end{frame}


\subsubsection{Autres fonctions}

\begin{frame}{Taille}
    La taille du CFG exécutable est uniquement intéressante d'un point de vue performances et connaître l'impact des différentes optimisations. Le calcul se fait de la même manière que pour le CFG.
\end{frame}

\begin{frame}{Recensement des variables et appels de blocs}
    De la même manière que lors de la phase CFG, les occurences des variables et blocs sont comptées afin de supprimer le code mort mais aussi pour l'inlining.
\end{frame}

\subsection{inlining}

Inliner un bloc consiste à intégrer son contenu dans le bloc appelant à la place de la dernière instruction (branchement) lorsqu'il s'agit d'un appel direct uniquement. Chaque argument du bloc inliné est remplacé par la variable qui lui a été assignée lors du branchement par le bloc appelant. Pour l'instant seuls les appels directs peuvent être inlinés. Si lors de l'appel des contextes étaient empilés sur la pile, alors le branchement du bloc inliné en tiendra compte. En particulier, si le branchement du bloc inliné est un retour de fonction (et si la pile n'est pas vide) celui-ci dépilera la pile et deviendra un saut direct. Dans les autres cas les contextes du bloc appelant sont empilés sur les contextes du bloc appelé, ce qui permet d'avoir des sauts vers l'intérieur d'une fonction.

\begin{frame}{Choix des blocs à inliner}
    Sont actuellement inlinés tous les blocs appelés exactement 1 fois (les blocs spécialisés lors de l'analyse du flot de contrôle sont ainsi tous concernés).
\end{frame}



\subsection{Interprétation}

C'est le CFG exécutable que j'interprête pour dans un premier temps m'assurer de la validité de toutes les transformations et dans un second temps réaliser des benchmarks.

\begin{frame}{Validité des phases de compilation}
    L'interprétation m'a permis de corriger de nombreuses erreurs à partir de divers tests focalisés. Néanmoins les tests en question sont très courts (moins d'une dizaine de lignes) et il est possible que d'autres erreurs apparaîssent pour des programmes plus longs.
\end{frame}

\begin{frame}{Benchmarks}
    Durant l'interprêtation j'enregistre diverses informations intéressantes, comme le nombre de sauts, de variables lues ou écrites. Celles-ci sont affichées après éxécution du programme pour identifier la pertinence de certaines optimisations.
\end{frame}



\section{Heuristiques d'inlining}

Les phases de compilation étant prêtes et à mes yeux suffisamment expressives pour permettre toute forme d'inlining, je détaille ici quelques idées d'heuristiques pour la suite du stage. De nombreux tests complets seront à réaliser pour à la fois vérifier la pertinence des heuristiques implémentées mais également en détecter de nouvelles.

\begin{frame}{Inlining partiel}
    Une technique possible sur laquelle je vais me pencher sera l'inlining partiel, c'est à dire potentiellement inliner seulement les premiers blocs d'une fonction. La manière dont je représente le programme me permet de sauter à l'intérieur d'une fonction, ce qui n'est actuellement pas possible avec flambda2. La question est donc de savoir s'il existe des cas où cette technique pourrait être intéressante, que ce soit à la fois en terme d'optimisations de la taille ou du temps d’exécution. Une première idée de situations intéressantes qui me vient à l'esprit est le grand nombre de fonctions en OCaml qui filtrent au début un de leurs arguments ce qui, à ma connaissance, se représente une fois compilé comme quelques instructions suivies d'un saut. Le filtrage en lui même n'est pas une opération spécialement coûteuse en terme d'espace, on transformerait ici un appel de fonction en un filtrage vers des blocs à "l'intérieur" de celle-ci (avec évidemment les opérations sur la pile qu'il convient de faire comme un appel classique). De plus l'inliner peut permettre de gagner en informations sur le motif, ce qui peut rendre possible de transformer le filtrage en appel direct, les gains seraient considérables.

    Un exemple qui me pousse à croire qu'une telle technique peut être prometteuse est fourni sur la section dédiée à flambda dans la documentation de OCaml :
    
    ```ocaml
    let f b x =
      if b then x else ... big expression ...
    
    let g x = f true x
    ```
    
    En appliquant les transformations pour faire apparaître les blocs, les branchements et les manipulations de la pile on obtient ce pseudo-code sous forme de basic blocks (sans distinguer les appels directs des appels indirects) :
    
    ```ocaml
    let rec f b x stack =
      if b then f0 x stack else f1 stack
    and f0 x stack =
      f2 x stack
    and f1 stack =
      f2 (... big expression ...) stack
    and f2 x (p::stack) =
      p x stack
    and g x stack =
      f true x (g0::stack)
    and g0 x (p::stack) =
      p x stack
    ```
    
    Dans le cas présent la fonction `f` peut être vue comme un bloc d'une seule instruction. L'idée est donc d'inliner systématiquement ce bloc (pas la fonction complète, d'où la notion d'inlining partiel), et on obtient le code suivant où l'appel vers `f` est inliné dans `g` :
    
    ```ocaml
    let rec f b x stack =
      if b then f0 x stack else f1 stack
    and f0 x stack =
      f2 x stack
    and f1 stack =
      f2 (... big expression ...) stack
    and f2 x (p::stack) =
      p x stack
    and g x stack =
      if true then f0 x (g0::stack) else f1 (g0::stack)
    and g0 x (p::stack) =
      p x stack
    ```
    
    Cet inlining n'est possible que si toutes les branches du `if` empilent les mêmes contextes sur la pile, ce qui est normalement toujours le cas quand le code est bien construit. Avec cet inlining, indépendamment de la valeur de `b`, on économise un saut et on se donne davantage d'informations sur le contexte dans le bloc inliné qui pourraient être utiles à d'éventuelles simplifications. Après simplifications, en supposant que le premier bloc de `f` est systématiquement inliné pour chaque appel et en inlinant les appels terminaux, on obtient le code suivant :
    
    ```ocaml
    let rec f0 x (p::stack) =
      p x stack
    and f1 (p::stack) =
      p (... big expression ...) stack
    and g x (p::stack) =
      p x stack
    ```
    
    Évidemment au stade actuel cette technique ne reste qu'une hypothèse et il faudra vérifier à la fois sa faisabilité et son efficacité. Il est par ailleurs fort probable qu'elle ne soit pas possible à mettre en place dans l'évaluateur de bytecode.
\end{frame}

\fi

\end{document}
